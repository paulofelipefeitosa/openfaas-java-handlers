#!/usr/bin/env python
import ctypes
import ctypes.util
import errno
import sys
import os
import time

# <sched.h> constants for unshare
CLONE_NEWNS = 0x00020000
CLONE_NEWPID = 0x20000000

# <sys/mount.h> - constants for mount
MS_REC = 16384
MS_PRIVATE = 1 << 18
MS_SLAVE = 1 << 19

# Load libc bindings
_libc = ctypes.CDLL(ctypes.util.find_library("c"), use_errno=True)

try:
	_unshare = _libc.unshare
except AttributeError:
	raise OSError(errno.EINVAL, "unshare is not supported on this platform")
else:
	_unshare.argtypes = [ ctypes.c_int ]
	_unshare.restype = ctypes.c_int

try:
	_setns = _libc.setns
except AttributeError:
	raise OSError(errno.EINVAL, "setns is not supported on this platform")
else:
	_setns.argtypes = [ ctypes.c_int, ctypes.c_int ]
	_setns.restype = ctypes.c_int

try:
	_mount = _libc.mount
except AttributeError:
	raise OSError(errno.EINVAL, "mount is not supported on this platform")
else:
	_mount.argtypes = [
		ctypes.c_char_p,
		ctypes.c_char_p,
		ctypes.c_char_p,
		ctypes.c_ulong,
		ctypes.c_void_p
	]
	_mount.restype = ctypes.c_int

try:
	_umount = _libc.umount
except AttributeError:
	raise OSError(errno.EINVAL, "umount is not supported on this platform")
else:
	_umount.argtypes = [ctypes.c_char]
	_umount.restype = ctypes.c_int


def run_criu():
	os.execlp('criu', *['criu'] + sys.argv[1:])


def wrap_restore():
	prerun_criu_ts = time.time()
	sys.stdout.write('%d\n' % int(prerun_criu_ts * 10**9))
	sys.stdout.flush()
	
	# Unshare pid and mount namespaces
	if _unshare(CLONE_NEWNS | CLONE_NEWPID) != 0:
		_errno = ctypes.get_errno()
		raise OSError(_errno, errno.errorcode[_errno])

	(r_pipe, w_pipe) = os.pipe()

	# Spawn the init
	if os.fork() == 0:
		os.close(r_pipe)

		# Mount new /proc
		if _mount(None, "/", None, MS_SLAVE|MS_REC, None) != 0:
			_errno = ctypes.get_errno()
			raise OSError(_errno, errno.errorcode[_errno])

		if _mount('proc', '/proc', 'proc', 0, None) != 0:
			_errno = ctypes.get_errno()
			raise OSError(_errno, errno.errorcode[_errno])

		# Spawn CRIU binary
		run_criu_ts = time.time()
		criu_pid = os.fork()
		if criu_pid == 0:
			run_criu()
			raise OSError(errno.ENOENT, "No such command")

		while True:
			try:
				(pid, status) = os.wait()
				if pid == criu_pid:
					status = os.WEXITSTATUS(status)
					break
			except OSError:
				status = -251
				break

		os.write(w_pipe, "%d\n" % status)
		#os.write(w_pipe, "%d\n" % int(run_criu_ts * 10**9))
		#os.write(w_pipe, "%d" % int(prerun_criu_ts * 10**9))

		os.close(w_pipe)

		if status != 0:
			sys.exit(status)

		while True:
			try:
				os.wait()
			except OSError:
				break

		sys.exit(0)

	# Wait for CRIU to exit and report the status back
	os.close(w_pipe)
	f_r_pipe = os.fdopen(r_pipe)
	status = f_r_pipe.readline()#os.read(r_pipe, 1024)
	#sys.stdout.write(f_r_pipe.readline())
	#sys.stdout.write(f_r_pipe.readline())
	f_r_pipe.close()
	
	if not status.isdigit():
		status_i = -252
	else:
		status_i = int(status)

	return status_i


action = sys.argv[1]

if action == 'restore':
	res = wrap_restore()
else:
	print 'Unsupported action %s for nswrap' % action
	res = -1

sys.exit(res)
